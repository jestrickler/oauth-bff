# ===========================================
# DOCKER COMPOSE - PRODUCTION-LIKE DEVELOPMENT
# ===========================================
#
# This setup mimics production architecture:
# - nginx reverse proxy on port 3000
# - Frontend and backend on SAME ORIGIN (same-site)
# - All traffic through nginx (no CORS needed)
# - Session cookies work perfectly (same-site)
#
# WHY THIS MATCHES PRODUCTION:
# 1. Same-origin: http://localhost:3000 for everything
# 2. nginx proxiesrequests (like production AWS ALB/nginx)
# 3. No CORS configuration needed
# 4. Cookies set by backend are valid for frontend
#
# PRODUCTION DIFFERENCE:
# - Production uses HTTPS (this uses HTTP for local dev)
# - Production domain (app.example.com vs localhost:3000)
# - Production has proper SSL certificates
#
# ===========================================

version: '3.8'

services:
  # ===========================================
  # FRONTEND BUILD - Build React app first
  # ===========================================
  frontend-build:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: bff-frontend-build
    volumes:
      - frontend-dist:/app/dist  # Named volume for dist output
    command: npm run build && echo "Frontend built successfully"
    networks:
      - bff-network

  # ===========================================
  # NGINX - Reverse Proxy
  # ===========================================
  # Serves frontend static files and proxies backend API
  # This is exactly how production works
  nginx:
    build:
      context: .
      dockerfile: nginx.Dockerfile
    container_name: bff-nginx
    ports:
      - "${PORT:-3000}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf.template:ro
      - frontend-dist:/usr/share/nginx/html:ro
    environment:
      - PORT=${PORT:-3000}
    depends_on:
      frontend-build:
        condition: service_completed_successfully
      backend:
        condition: service_started
    networks:
      - bff-network
    restart: unless-stopped

  # ===========================================
  # BACKEND - Spring Boot
  # ===========================================
  backend:
    build:
      context: ./server
      dockerfile: Dockerfile
    container_name: bff-backend
    environment:
      # GitHub OAuth credentials (set in .env file)
      - GITHUB_CLIENT_ID=${GITHUB_CLIENT_ID}
      - GITHUB_CLIENT_SECRET=${GITHUB_CLIENT_SECRET}
      
      # Spring profile (docker = same-site via nginx)
      - SPRING_PROFILES_ACTIVE=docker
      
      # External port (what browser sees) - set in docker-compose
      # This allows Spring to reconstruct correct OAuth redirect URIs
      - PORT=${PORT:-3000}
    ports:
      - "8080:8080"  # Exposed for debugging only
    networks:
      - bff-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ===========================================
  # FRONTEND DEV SERVER (Optional)
  # ===========================================
  # Uncomment for hot-reload development
  # Keep commented for production-like build
  #
  # frontend:
  #   build:
  #     context: ./client
  #     dockerfile: Dockerfile.dev
  #   container_name: bff-frontend
  #   volumes:
  #     - ./client:/app
  #     - /app/node_modules
  #   environment:
  #     - VITE_API_BASE_URL=http://localhost:3000
  #   networks:
  #     - bff-network
  #   command: npm run dev

networks:
  bff-network:
    driver: bridge

volumes:
  frontend-dist:  # Shared volume for frontend build output

# ===========================================
# USAGE
# ===========================================
#
# 1. Create .env file with your GitHub OAuth credentials:
#    cp .env.example .env
#    (edit .env with real values - NOT checked in)
#
# 2. Run everything:
#    docker compose up --build
#
# 3. Access app:
#    http://localhost:3000
#
# 4. Login:
#    http://localhost:3000/oauth2/authorization/github
#
# 5. Logs:
#    docker compose logs -f backend
#
# 6. Stop:
#    docker compose down
#
